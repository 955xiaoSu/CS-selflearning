# Heap Exploitation —— UAF

### 前言

笔者最近跟学委吴一起接了软件安全测试中的 Heap Exploitation Project，借此 blog 梳理学习思路。

### 什么是堆？

借 stackoverflow & geeksforgeeks 的回答，先大致了解一下堆是个什么东西，与我们所熟悉的栈又有怎样的区别和联系。

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption><p><a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap</a></p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption><p><a href="https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/">https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/#</a></p></figcaption></figure>

通过以上两张图片，相信读者已经能建立起对堆的初步印象。接下来就可以愉快地讨论堆的实现方式与利用。再次声明，以下讨论的堆，均指**运行内存中的堆区域**，该区域由程序员手动申请、手动释放，被同一个进程全局共享。

### 堆的种类与实现方式

从古到今，笔者了解到的堆实现方式有以下七种：

```
dlmalloc  – General purpose allocator
ptmalloc2 – glibc 
jemalloc  – FreeBSD and Firefox
tcmalloc  – Google
libumem   – Solaris
nedmalloc
Hoar
```

为了不耍流氓，我们定义讨论的范围为采用 **ptmalloc2** 的 **glibc**。试试

### UAF



### **Linux kernel heap feng shui in 2022 学习笔记**

_该文内容较杂，因此采用分点记录的方式._

1. 该文总结了 allocator 的实现机制对堆利用的影响；
2. kernel 中两种常见的动态分配机制如下:
   1. General-purpose allocations performed using `kmalloc/kzalloc/...` API
   2. Special-purpose allocations via `kmem_cache_create/kmem_cache_alloc`
3. Slab 是 Linux 内核中的一种内存分配机制，用于高效地管理内核数据结构和对象的内存分配和释放。Slab 分配器的主要目标是减少内存分配和释放的开销，以提高系统性能。**Slab 分配器通过预分配一定大小的内存块并将它们组织成 slabs，然后在需要时分配这些内存块，从而减少了内存碎片和频繁的内存分配操作。**Slab 分配器通常管理多个 slab 缓存，每个缓存用于不同大小的内存块。这些缓存通常包括三种类型：
   1. Slab缓存：用于保存已分配的内存块。
   2. Slab未分配缓存：用于保存已分配但尚未使用的内存块，以便后续分配。
   3. Slab空闲缓存：用于保存完全未使用的内存块。
4. **对齐问题的潜在利用**：攻击者可以利用对齐问题来修改数据结构的大小，进而改变其行为。例如，他们可能故意构造一个对象，以便它与某个通用缓存别名化，从而可以操纵通用缓存并导致不安全操作。但安全机制近年来也在不断地更新：
   * `cred_jar` 在 kernel version > 4.4 的情况下加入 SLAB\_ACCOUNT 标签，使得其 standalone 免受其攻击。
   *   安全的函数（`copy_to_user` / `copy_from_user`）被逐步引入，更加严格的检测机制使漏洞利用难以下手。

       <figure><img src="../.gitbook/assets/image (2).png" alt="" width="497"><figcaption></figcaption></figure>
   * _A freelist pointer randomisation `CONFIG_SLAB_FREELIST_RANDOM` was introduced in 4.8 and is now enabled by default on most modern distributions._

### References

1. [系统理解 Arm Heap Exploitation](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
2. [Understanding glibc malloc](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)
3. [glibc malloc source code](https://github.com/iromise/glibc/blob/master/malloc/malloc.c)
4. [了解 linux kernel heap](https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf)
5. [对以往 linux heap 的研究总结](https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022)
6. [ctfwiki-UAF](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
7. [深入理解 heap exploitation](https://github.com/shellphish/how2heap)
